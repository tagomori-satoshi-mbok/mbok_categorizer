# システム概要

このドキュメントでは、カテゴリーデータの加工から検索 API のレスポンスまでの処理を、初心者でも追いやすい形で説明します。高校数学レベルの知識があれば概要を理解できる内容になっています。

## 1. データ準備パイプライン

最初に手元にあるのは `categories` というタブ区切りファイルです。このファイルにはカテゴリ ID、名称、親子関係などの生データが含まれています。

1. **最終カテゴリの抽出 (`final_categories.txt`)**
   - `transform_categories.py` を使って、親カテゴリとして登場する ID を除外し、末端（叶）カテゴリだけを抜き出します。
   - 各カテゴリについて「親カテゴリ > 子カテゴリ > ... > 最終カテゴリ」という形の階層パスを文字列で付与します。
   - こうすることで、「実際に商品がぶら下がるカテゴリ」だけを対象にでき、無駄なベクトル化を避けられます。

2. **属性ごとの整理 (`final_categories.json`)**
   - `categories_to_json.py` で階層パスを分解し、`top_level`・`domain`・`entity`・`item` などの属性に展開します。
   - JSON 配列の 1 要素が 1 カテゴリの辞書になり、検索時に参照しやすくなります。

3. **辞書の生成・更新 (`dictionary/*.json`)**
   - カテゴリ名に含まれるターゲット（キッズ・メンズなど）やサイズ情報を補助的に認識するために、辞書を整備しています。
   - 直接ベクトル化するだけでは拾いきれない表記ゆれや略称を補うため、Gemini を使って候補語を集めて手動確認・マージしています。
   - 検索クエリからカテゴリ構造を推定するときに、辞書があるとタグ付け精度が上がります。

4. **ベクトル化 (`final_categories_embeddings.jsonl`)**
   - `gemini_attribute_embeddings.py` により、`entity`・`item`・`target` などの属性ごとに Gemini のテキスト埋め込み API を呼び出します。
   - JSON Lines 形式で 1 行に「カテゴリーID・属性名・原文・ベクトル」を保存します。
   - このファイルが検索アルゴリズムの心臓部で、API 起動時にメモリへロードされます（約 480MB）。

### 生の `categories` を直接ベクトル化しない理由

- 生データには中間カテゴリや運用上のメモ欄など、検索対象として不要な情報が含まれています。
- 階層構造をそのままベクトル化すると、特徴的な語よりもノイズが多くなり、類似度計算の精度が落ちます。
- 先に文字列を整理・分解し、辞書でタグ付けしやすい形にすることで、検索クオリティが高まります。
- メモリ使用量と API レイテンシを抑えるためにも、必要最小限のカテゴリに絞ってベクトル化する設計にしています。

## 2. API のリクエスト処理フロー

`POST /search` にテキストを送ったときの処理を段階的に追うと、以下の通りです。

1. **入力のバリデーション**
   - `query`（テキスト）か `embedding`（数値配列）のどちらかが必須です。
   - `attributes`（検索対象とする属性）が指定されていなければ、`entity` / `item` / `target` の全てを対象にします。

2. **ベクトル生成**
   - `embedding` が既に指定されていればそれを使用。
   - 指定がない場合は Gemini Embedding API を呼び出し、`query` を 768 次元のベクトルに変換します。

3. **類似度計算**
   - 事前に読み込んでおいた `final_categories_embeddings.jsonl` のベクトルと比較します。
   - 各属性ごとの埋め込み行列（NumPy 行列）をメモリに保持し、クエリベクトルとの **コサイン類似度** を一括計算します。
   - コサイン類似度は「2 つのベクトルの角度」を測る指標で、値が 1 に近いほど意味が似ているとみなします。高校数学の内積とノルムを使い、\( \frac{\vec{a} \cdot \vec{b}}{\|\vec{a}\| \|\vec{b}\|} \) で求めます。

4. **上位結果の抽出**
   - 属性ごとの行列から上位 `top_k` 件のスコアを取り出し、スコア順にソートしてまとめます。
   - 同じカテゴリでも属性が異なれば別の結果として扱われます。

5. **カテゴリ情報の補完**
   - `final_categories.json` の内容をメモリに持っており、`category_id` から階層情報や原文（`entity`・`item`）を取得してレスポンスに含めます。

6. **レスポンス生成**
   - 最終的に `category_id`、`attribute`、`score`、`category`（階層情報）を含む JSON を返します。
   - 付随情報として、検索に使った属性や結果件数などのメタデータも返却します。

## 3. パフォーマンスと運用上の工夫

- **JSON/ベクトルをメモリに読み込み**: API 起動時に `final_categories_embeddings.jsonl` と `final_categories.json` を読み込み、NumPy 行列と辞書に展開してからサービスを開始します。これによりクエリ処理はディスク I/O を伴わず、高速に応答できます。
- **属性ごとの分割**: `entity` や `item` など、属性ごとにベクトルを分けて保存しています。不要な属性を検索対象から外せるため、計算量を抑えられます。
- **Leaf カテゴリのみに絞り込み**: 末端カテゴリだけをベクトル化することでデータ量を縮小しています。これによりメモリ消費と類似度計算のコストが最小限で済みます。
- **辞書によるノイズ削減**: ターゲットやサイズ、固有名詞などの辞書を併用することで、ベクトル化前の文字列を正規化し、検索精度を高めています。
- **Cloud Run 向け最適化**: 大容量ファイルを含むため、メモリ 2Gi/CPU 2 の設定でデプロイし、起動タイムアウトも 600 秒に拡張しています。また、ヘルスチェック用のエイリアス（`/`・`/health`・`/ping`）を用意し、`/healthz` は 404 を返す点を README に記載しています。

## 4. まとめ

- **カテゴリーデータの段階的な整形**（`categories` → `final_categories.txt` → `final_categories.json`）により、無駄なベクトル化を避けつつ検索に必要な情報だけを抽出しています。
- **辞書と埋め込み** を併用することで、表記ゆれやターゲット識別を補助し、検索精度を向上させています。
- **API はクエリをベクトル化してコサイン類似度で検索**し、メモリ常駐のデータ構造を使って高速化しています。
- **大容量ファイルは Git 管理外とし、外部ストレージで共有**することで、コードとデータの責務を分離しています。

運用担当者はこの流れを理解していれば、新しいカテゴリ追加や辞書更新、Cloud Run へのデプロイを自信を持って実行できます。
